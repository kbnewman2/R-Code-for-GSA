---
title: "GR6J_GSA_evaluate"
author: "KBN"
output: html_document
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Note: The folders used by GR6J_GSA_generate are again used here.

 This code takes GR6J output and calculates GSA measures. User selects one of the following: Morris, Sobol, VARS-TO, Regression, Regression Tree & Random Forest together, or Gaussian Process Regression. 
 
Because of computational expense, GPR uses on n=500 randomly selected combinations from target,N specified in GR6J_GSA_generate.

Outputs per GSA method:
Morris: scatterplots of variance vs mu.star, and barplots of DGSM
Sobol: barplots of S_{1,k} and T_k
VARS-TO; barplots of T_k
Reg: barplots of SRC
RegTree/Random Forest: Variable importance plots for both; regression tree; In chunk 8 heatswitch <- FALSE to NOT produce heatmap
GPR:  Inverse range and SRC

<hr style="border:2px solid blue">

### 0. Load Libraries, set data paths. Includes functions like kge2.fun.
```{r, 0. Library Load, message=FALSE, eval=TRUE, echo=TRUE, warning=FALSE}
dir.create(tempdir())
t1 <- proc.time()[3]

verbose <- TRUE

#--- Choosing type of SA -------------
choice <- "Morris"
# choice <- "Sobol"
# choice <- "VARS.TO"
# choice <- "Reg.analysis"
#  choice <- "RegTree.RF.analysis"
#  choice <- "GPR.analysis"

root       <- "D:/GR6J/"
Rcode.path <- paste0(root,"R Code/") 
Data.path  <- paste0(root,"Data/")
Output     <- paste0(root,"Output/")

library(sensobol)
library(sensitivity)#
library(rpart)      # for RegTree 
library(rpart.plot) # for RegTree visualization
library(treeheatr)
library(partykit)
library(ggparty)
library(randomForest)
library(RobustGaSP) # rgasp()

library(tidyverse)
library(lubridate)
library(readxl)
library(tinytex)

library(lhs)
library(boot)
library(ggplot2)
library(gridExtra)

mytitle <- function(x) graphics::mtext(text=x,side=3,outer=TRUE)

KGE.switch <- TRUE

Morris.eval     <- FALSE; Morris.echo     <- FALSE
Sobol.eval      <- FALSE; Sobol.echo      <- FALSE
VARS.TO.eval    <- FALSE; VARS.TO.echo    <- FALSE
Reg.eval        <- FALSE; Reg.echo        <- FALSE
RegTree.RF.eval <- FALSE; RegTree.RF.echo <- FALSE
GPR.eval        <- FALSE; GPR.echo        <- FALSE

kge2.fun <- function(model,obs) {
  # Removing missing values in obs.  Seems ok. 
  ok.values <- !is.na(obs)
  model <- model[ok.values]
  obs   <- obs[ok.values]
   if(sd(model)!=0) {
    #r <- cor(model,obs,use="complete.obs")
    r <- cor(model,obs,use="na.or.complete")
  } else r <- 0
 beta <- mean(model)/mean(obs,na.rm=TRUE)
  alpha <- (sd(model)/mean(model))/(sd(obs,na.rm=TRUE)/mean(obs,na.rm=TRUE))
  KGE <- 1-sqrt((1-r)^2 + (1-beta)^2 + (1-alpha)^2)
  return(KGE)
}

 
```

<hr style="border:2px solid blue">

### 1. Read in GR6J Output, etc
```{r, 1. Load GR6J output, eval=TRUE, echo=FALSE}
# Read: *_comb.RData w/ x.Morris, num.comb, par.sample, par.names
# Read: ymat_*.Rdata w/ ymat, chosen.vars, chosen.dates.char, y.Qsim.mat
 
switch(choice,
     Morris = {
       Morris.eval <- TRUE; Morris.echo<- TRUE
       cat("---------------------Analysis with Morris measure \n")
       Output <- paste0(Output,"1_Morris/")
       load(file=paste0(Output,"Morris_GR6J_comb.RData"))
       load(file=paste0(Output,"ymat_Morris_GR6J.Rdata"))
    
      if(verbose) {
        cat("names in x.Morris=\n")
        print(names(x.Morris))
        print(x.Morris$X[1:3,])
        print(x.Morris$factors)
      }
      num.par <- ncol(x.Morris$X)
     },
     
      Sobol = {
        Sobol.eval <- TRUE; Sobol.echo <- TRUE
        cat("---------------------Analysis with Sobol indices \n")
        Output <- paste0(Output,"2_Sobol/")
        load(file=paste0(Output,"Sobol_GR6J_comb.RData"))
        load(file=paste0(Output,"ymat_Sobol_GR6J.Rdata"))
      },
     
      VARS.TO = {
         VARS.TO.eval <- TRUE; VARS.TO.echo <- TRUE
         Output <- paste0(Output,"3_VARS.TO/")
         load(file=paste0(Output,"varsto_GR6J_comb.RData")) 
         load(file=paste0(Output,"ymat_varsto_GR6J.Rdata"))   
      },
     
      Reg.analysis = {
         Reg.eval <- TRUE; Reg.echo <- TRUE
         Output <- paste0(Output,"4_Regression/")
         load(file=paste0(Output,"regression_GR6J_comb.RData")) 
         load(file=paste0(Output,"ymat_regression_GR6J.RData"))   
        },
     
      RegTree.RF.analysis = {
        RegTree.RF.eval   <- TRUE; RegTree.RF.eval  <- TRUE
        Output.rf <-  paste0(Output,"5_RegTree_RF/")
        Output    <-  paste0(Output,"4_Regression/")
        load(file=paste0(Output,"regression_GR6J_comb.RData")) 
        load(file=paste0(Output,"ymat_regression_GR6J.RData"))   
       },
     
      GPR.analysis = {
       GPR.eval<- TRUE; GPR.echo<- TRUE 
       GPR.mean <- TRUE
       Output.GPR <- paste0(Output,"6_GPReg/")
       Output    <-  paste0(Output,"4_Regression/")
       load(file=paste0(Output,"regression_GR6J_comb.RData")) 
       load(file=paste0(Output,"ymat_regression_GR6J.RData"))   
     }
    )
 
# If truncating outputs, need to modify Sobol evaluation
cat("full ymat \n")
head(ymat)

#ymat <- ymat[,4:6] # used in paper
num.outputs  <- ncol(ymat)
output.names <- dimnames(ymat)[[2]]

```

<hr style="border:2px solid blue">
 
### 2. Obs'd Data loaded for KGE calculations
Load catchment data or create BasinObs (data.frame of daily hydrometeorological observations time series)
```{r, 2. Data Load, eval=KGE.switch, echo=KGE.switch,warning=FALSE, message=FALSE}
#DatesR: dates in the POSIXt format
#P: average precipitation [mm/day]
#T: catchment average air temperature [???] Optional, required for snow model
#E: catchment average potential evapotranspiration [mm/day]
#Qls: outlet discharge [l/s]
#Qmm: outlet discharge [mm/day]....only accepts mm/day

BasinObs <- read_excel(paste0(Data.path,"Coull_GR6J_R.xlsx")) 
BasinObs <- as.data.frame(BasinObs)

# Copy PE_oudin into E column
BasinObs$E <- BasinObs$PE_oudin

```

<hr style="border:2px solid blue">

### 3. Calculate KGE Metric only for Q "outflow" (QSim vs Qmm)
```{r, 3. KGE Metric, eval=KGE.switch, echo=KGE.switch}
# using y.Qsim.mat
# Field data, want Qmm for the same dates as in the columns of y.Qsim.mat
##          DatesR         P          E       Qls      Qmm          T   PE_oudin
## 2920 2020-12-29 0.3312133 0.05953286  826.8768 1.419648 -0.6214268 0.06643285
## 2921 2020-12-30 2.8841136 0.05676286  782.8340 1.344032 -1.5797242 0.05238760

ok.dates <- seq(ymd("2014-10-01"),ymd("2014-10-31"),by=1)
ok.dates <- as.character(ok.dates)
print(ok.dates[1:5])
temp        <- BasinObs$Qmm 
names(temp) <- BasinObs$DatesR
field.Q     <- temp[ok.dates]
print(field.Q)

cat("Number of field obs=",length(field.Q),"and simulated=",length(ok.dates),
    "dimension of sims=",dim(y.Qsim.mat),"\n")

# Note: Coull is missing 47 values, starting in Jan 2016
cat("summary of field obs \n")
print(summary(field.Q))

KGE.metric <- numeric(num.comb)
for(i in 1:num.comb) {
  KGE.metric[i] <- kge2.fun(model=y.Qsim.mat[i,ok.dates],obs=field.Q)
}
cat("KGE metric is calculated using",sum(!is.na(field.Q)),"\n")
print(summary(KGE.metric))

```

<hr style="border:2px solid blue">

### 4. Calculate Morris measures and produce plots
```{r,4. Morris measures, eval=Morris.eval, echo=Morris.echo, warning=FALSE, message=FALSE}

# This is calculating Morris measures on individual outputs & KGE of outflow 

# Creating 2 matrices to be filled w/ Morris mustar and sigma
#  num.outputs      <- ncol(ymat)
#  output.names     <- colnames(ymat)
  if(verbose) {
    cat("GR6J Outputs from Morris runs \n")
    print(output.names)
  }
  Morris.Results.mustar <-  matrix(data=NA,
          nrow=length(par.names),
          ncol=length(output.names))
  dimnames(Morris.Results.mustar) <- list(par.names,output.names)
  Morris.Results.sigma <- Morris.DGSM <- Morris.Results.mustar

  my.cex <- 0.9
  my.cex <- 1.1
  for(i in 1:num.outputs) {
    cat("\n **** Morris",output.names[i],"***** \n")
    temp <- ymat[,output.names[i]]
      
    z <- x.Morris
    tell(x=z,y=temp)
    #the print command creates a df w/ mu, mu.star, and sigma
    #  where mu.star is simply the absolute value of mu
    out <- print(z)
    row.names(out) <- par.names
    x <- out[,"mu.star"]
    names(x) <- row.names(out)
    if(verbose) {
      cat("------ Largest to smallest mu* \n")
      print(round(rev(sort(x)),2))
    }
    Morris.Results.mustar[,i] <- out[,"mu.star"]
    Morris.Results.sigma[,i]  <- out[,"sigma"]
    Morris.DGSM[,i]           <- sqrt(out[,"mu"]^2 + out[,"sigma"]^2)

    # values to control plot limits
    delta.x <- 0.15*(max(out$mu)-min(out$mu))
    delta.y <- 0.15*(max(out$sigma)-min(out$sigma))

    #my.xlim <- c(min(out$mu)-delta.x, max(out$mu)+delta.x)
    my.xlim <- c(0.85*min(out$mu.star), 1.15*max(out$mu.star))
    my.ylim <- c(min(out$sigma)-delta.y,max(out$sigma)+delta.y)
    
    plot(out[,"mu.star"],out[,"sigma"],type="n",xlab=expression(mu),
       ylab=expression(sigma),
       #xlim=my.xlim,ylim=my.ylim,
       main=paste(output.names[i]))
    text(out[,"mu.star"],out[,"sigma"],par.names,cex=my.cex)
    dev.copy2pdf(file=paste0(Output,"GR6J_Morris_",output.names[i],
                             ".pdf"))
    
   barplot(Morris.DGSM[,i],main=output.names[i],cex.names=1.1)
   dev.copy2pdf(file=paste0(Output,"GR6J_MorrisDGSM_",output.names[i],
                            ".pdf"))
  }
  
  print(signif(Morris.Results.mustar,3))
  
  if(KGE.switch) {
   # KGE on Qsim using y.Qsim.mat
    temp <- KGE.metric
    z <- x.Morris
    tell(x=z,y=temp)
    #the print command creates a df w/ mu, mu.star, and sigma
    #  where mu.star is simply the absolute value of mu
    out <- print(z)
    row.names(out) <- par.names
    x <- out[,"mu.star"]
    names(x) <- row.names(out)
    if(verbose) {
      cat("------ Largest to smallest mu* \n")
      print(round(rev(sort(x)),2))
    }
    Morris.KGE.Results.mustar <- out[,"mu.star"]
    Morris.KGE.Results.sigma  <- out[,"sigma"]

    # values to control plot limits
    my.xlim <- c(0.85*min(Morris.KGE.Results.mustar),
                 1.15*max(Morris.KGE.Results.mustar))
    my.ylim <- c(min(Morris.KGE.Results.sigma),
                 max(Morris.KGE.Results.sigma))
  
    plot(Morris.KGE.Results.mustar,Morris.KGE.Results.sigma,
         type="n",xlab=expression(mu),
       ylab=expression(sigma),
       xlim=my.xlim,ylim=my.ylim,
       main="KGE.Q.Morris")
   text(out[,"mu.star"],out[,"sigma"],par.names,cex=my.cex)
   mytitle(paste("GR6J: Morris elem effects with",num.comb,"combos"))
   dev.copy2pdf(file=paste0(Output,"Morris_GR6J_KGE_Q.pdf"))
  }
  
  #-- save Morris results for Kendall W analysis
  if(KGE.switch) {
    save(Morris.Results.mustar, Morris.Results.sigma,Morris.DGSM,
       Morris.KGE.Results.mustar, Morris.KGE.Results.sigma,
       file=paste0(Output,"Morris_GR6J_Results.RData"))
  } else {
     save(Morris.Results.mustar, Morris.Results.sigma,Morris.DGSM,
       file=paste0(Output,"Morris_GR6J_Results.RData"))
  }
  

```

<hr style="border:2px solid blue">

### 5A. Calculate Sobol 
```{r, 5A. Sobol,eval=Sobol.eval,echo=Sobol.echo}

  head(ymat,n=4)
  print(dim(ymat))
  num.outputs <- ncol(ymat)
  output.names <- colnames(ymat)
     
    type <- "norm"
    conf <- 0.95
    order <- "first"

    ## Look at Si, Ti
    R <- 100 # number of bootstrap replicates
  
  Sobol.Results.Si <-  matrix(data=NA,
    nrow=length(par.names),ncol=length(output.names),
    dimnames=list(par.names,output.names))
  Sobol.Results.Ti <- Sobol.Results.Si
  
  Sobol.indices.list <- list()
  # Loop just to extract indices, w/o plotting
  for(i in 1:num.outputs) {
     y <- ymat[,i]
     indices <- sobol_indices(Y=y,N=N,params=par.names,order=order,
                          boot=TRUE,R=R,type=type,conf=conf)

     Sobol.indices.list[[i]] <- indices
       #print(names(indices)) #"results" "si.sum"  "first"   "total"   "C"
       # results has the matrix, si.sum=sum over Si?, first & total=types
       # cat("results \n")
       # print(indices$"results")
       # print(class(indices$"results")) #"data.table" "data.frame"

     ok <- indices$results$sensitivity == "Si"
     Sobol.Results.Si[,i] <- indices$results$original[ok]
     ok <- indices$results$sensitivity == "Ti"
     Sobol.Results.Ti[,i] <- indices$results$original[ok]
  }

  
  names(Sobol.indices.list) <- output.names
  print(Sobol.Results.Ti)
  
  if(KGE.switch) {
  # Calculate Sobol for KGE values
   KGE.indices <- sobol_indices(Y=KGE.metric,N=N,params=par.names,
      order=order,boot=TRUE,R=R,type=type,conf=conf)
   ok <- KGE.indices$results$sensitivity == "Si"
   Sobol.Results.KGE.Si <- KGE.indices$results$original[ok]
   ok <- KGE.indices$results$sensitivity == "Ti"
   Sobol.Results.KGE.Ti <- KGE.indices$results$original[ok]
   cat("**** Sobol KGE results **** \n")
   print(cbind(Sobol.Results.KGE.Si,Sobol.Results.KGE.Ti))
  }
  
  if(KGE.switch) {
     save(Sobol.Results.Si,Sobol.Results.Ti,
         Sobol.Results.KGE.Si, Sobol.Results.KGE.Ti,
     file=paste0(Output,"Sobol_GR6J_Results.RData"))
  } else {
        save(Sobol.Results.Si,Sobol.Results.Ti,
     file=paste0(Output,"Sobol_GR6J_Results.RData"))
  }
  
```

### 5B. Sobol plots 
```{r, 5B. Sobol Plots, eval=Sobol.eval, echo=Sobol.echo}
# Tedious: cannot loop through the outputs

#pdf(file=paste0(Output,"Sobol_GR6J_multiple.pdf"))
 
cat("Output names for Sobol eval \n")
print(output.names)
print(output.names[11])
cat("output list object names \n")
print(names(Sobol.indices.list))

 i <- 1
  #cat("\n **************  Results for output",output.names[i])
   indices <- Sobol.indices.list[[i]]
   cols <- colnames(indices$results)[1:5]
   indices$results[, (cols):= round(.SD, 3), .SDcols = (cols)]
   ind.dummy <- sobol_dummy(Y = y, N=N,params=par.names,
                              boot = TRUE,R = R)
   p1 <- plot(indices,dummy=ind.dummy,cex.names=1.1)+
          ggtitle(label=output.names[i]) +   guides(scale="none")
   print(p1)
   dev.copy2pdf(file=paste0(Output,"GR6J_Sobol_",output.names[i],
                            ".pdf"))

    i <- 2
  #cat("\n **************  Results for output",output.names[i])
   indices <- Sobol.indices.list[[i]]
   cols <- colnames(indices$results)[1:5]
   indices$results[, (cols):= round(.SD, 3), .SDcols = (cols)]
   ind.dummy <- sobol_dummy(Y = y, N=N,params=par.names,
                              boot = TRUE,R = R)
    p2 <- plot(indices,dummy=ind.dummy)+
     ggtitle(label=output.names[i]) +   guides(scale="none")
    print(p2)
    dev.copy2pdf(file=paste0(Output,"GR6J_Sobol_",output.names[i],".pdf"))

  i <- 3
  #cat("\n **************  Results for output",output.names[i])
   indices <- Sobol.indices.list[[i]]
   cols <- colnames(indices$results)[1:5]
   indices$results[, (cols):= round(.SD, 3), .SDcols = (cols)]
   ind.dummy <- sobol_dummy(Y = y, N=N,params=par.names,
                              boot = TRUE,R = R)
    p3 <- plot(indices,dummy=ind.dummy)+
     ggtitle(label=output.names[i]) +   guides(scale="none")
    print(p3)
   dev.copy2pdf(file=paste0(Output,"GR6J_Sobol_",output.names[i],".pdf"))
   
   i <- 4
  #cat("\n **************  Results for output",output.names[i])
   indices <- Sobol.indices.list[[i]]
   cols <- colnames(indices$results)[1:5]
   indices$results[, (cols):= round(.SD, 3), .SDcols = (cols)]
   ind.dummy <- sobol_dummy(Y = y, N=N,params=par.names,
                              boot = TRUE,R = R)
    p4 <- plot(indices,dummy=ind.dummy)+
     ggtitle(label=output.names[i]) +   guides(scale="none")
    print(p4)
   dev.copy2pdf(file=paste0(Output,"GR6J_Sobol_",output.names[i],".pdf"))
   
   i <- 5 
  #cat("\n **************  Results for output",output.names[i])
   indices <- Sobol.indices.list[[i]]
   cols <- colnames(indices$results)[1:5]
   indices$results[, (cols):= round(.SD, 3), .SDcols = (cols)]
   ind.dummy <- sobol_dummy(Y = y, N=N,params=par.names,
                              boot = TRUE,R = R)
    p5 <- plot(indices,dummy=ind.dummy)+
     ggtitle(label=output.names[i]) +   guides(scale="none")
    print(p5)
   dev.copy2pdf(file=paste0(Output,"GR6J_Sobol_",output.names[i],".pdf"))
   
   i <- 6
  #cat("\n **************  Results for output",output.names[i])
   indices <- Sobol.indices.list[[i]]
   cols <- colnames(indices$results)[1:5]
   indices$results[, (cols):= round(.SD, 3), .SDcols = (cols)]
   ind.dummy <- sobol_dummy(Y = y, N=N,params=par.names,
                              boot = TRUE,R = R)
    p6 <- plot(indices,dummy=ind.dummy)+
     ggtitle(label=output.names[i]) +   guides(scale="none")
    print(p6)
   dev.copy2pdf(file=paste0(Output,"GR6J_Sobol_",output.names[i],".pdf"))
   
    i <- 7
  #cat("\n **************  Results for output",output.names[i])
   indices <- Sobol.indices.list[[i]]
   cols <- colnames(indices$results)[1:5]
   indices$results[, (cols):= round(.SD, 3), .SDcols = (cols)]
   ind.dummy <- sobol_dummy(Y = y, N=N,params=par.names,
                              boot = TRUE,R = R)
    p7 <- plot(indices,dummy=ind.dummy)+
     ggtitle(label=output.names[i]) +   guides(scale="none")
    print(p7)
   dev.copy2pdf(file=paste0(Output,"GR6J_Sobol_",output.names[i],".pdf"))
   
    i <- 8
  #cat("\n **************  Results for output",output.names[i])
   indices <- Sobol.indices.list[[i]]
   cols <- colnames(indices$results)[1:5]
   indices$results[, (cols):= round(.SD, 3), .SDcols = (cols)]
   ind.dummy <- sobol_dummy(Y = y, N=N,params=par.names,
                              boot = TRUE,R = R)
    p8 <- plot(indices,dummy=ind.dummy)+
     ggtitle(label=output.names[i]) +   guides(scale="none")
    print(p8)
   dev.copy2pdf(file=paste0(Output,"GR6J_Sobol_",output.names[i],".pdf"))
   
    i <- 9
  #cat("\n **************  Results for output",output.names[i])
   indices <- Sobol.indices.list[[i]]
   cols <- colnames(indices$results)[1:5]
   indices$results[, (cols):= round(.SD, 3), .SDcols = (cols)]
   ind.dummy <- sobol_dummy(Y = y, N=N,params=par.names,
                              boot = TRUE,R = R)
    p9 <- plot(indices,dummy=ind.dummy)+
     ggtitle(label=output.names[i]) +   guides(scale="none")
    print(p9)
   dev.copy2pdf(file=paste0(Output,"GR6J_Sobol_",output.names[i],".pdf"))
   
    i <- 10
  #cat("\n **************  Results for output",output.names[i])
   indices <- Sobol.indices.list[[i]]
   cols <- colnames(indices$results)[1:5]
   indices$results[, (cols):= round(.SD, 3), .SDcols = (cols)]
   ind.dummy <- sobol_dummy(Y = y, N=N,params=par.names,
                              boot = TRUE,R = R)
    p10 <- plot(indices,dummy=ind.dummy)+
     ggtitle(label=output.names[i]) +   guides(scale="none")
    print(p10)
   dev.copy2pdf(file=paste0(Output,"GR6J_Sobol_",output.names[i],".pdf"))
   
     i <- 11
  #cat("\n **************  Results for output",output.names[i])
   indices <- Sobol.indices.list[[i]]
   cols <- colnames(indices$results)[1:5]
   indices$results[, (cols):= round(.SD, 3), .SDcols = (cols)]
   ind.dummy <- sobol_dummy(Y = y, N=N,params=par.names,
                              boot = TRUE,R = R)
    p11 <- plot(indices,dummy=ind.dummy)+
     ggtitle(label=output.names[i]) +   guides(scale="none")
    print(p11)
   dev.copy2pdf(file=paste0(Output,"GR6J_Sobol_",output.names[i],".pdf"))
   
     i <- 12
  #cat("\n **************  Results for output",output.names[i])
   indices <- Sobol.indices.list[[i]]
   cols <- colnames(indices$results)[1:5]
   indices$results[, (cols):= round(.SD, 3), .SDcols = (cols)]
   ind.dummy <- sobol_dummy(Y = y, N=N,params=par.names,
                              boot = TRUE,R = R)
    p12 <- plot(indices,dummy=ind.dummy)+
     ggtitle(label=output.names[i]) +   guides(scale="none")
    print(p12)
   dev.copy2pdf(file=paste0(Output,"GR6J_Sobol_",output.names[i],".pdf"))
   
  #Print all on one page. Just Qsim
  pdf(file=paste0(Output,"Sobol_GR6J.pdf"))
  #grid.arrange(p1, p2, p3,p4,p5,p6, 
  #             p7, p8, p9,p10,p11,p12,
  #           ncol = 3, nrow = 4)
   grid.arrange(p3,p6,p9,p12,
             ncol = 2, nrow = 2)
  # dev.copy2pdf(file=paste0(Output,"Sobol_GR6J.pdf"))
  dev.off()
   
   if(KGE.switch) {
  
    cat("**** Plotting Sobol based on KGE ***** \n")
   #---------- Repeat w/ KGE ----------------------------------
   indices <- KGE.indices 
   cols <- colnames(indices$results)[1:5]
   indices$results[, (cols):= round(.SD, 3), .SDcols = (cols)]
   ind.dummy <- sobol_dummy(Y = y, N=N,params=par.names,
                              boot = TRUE,R = R)   
   
   #pdf(file=paste0(Output,"Sobol_GR6J_KGE_Q.pdf"))
   p.KGE <- plot(indices,dummy=ind.dummy)+
     ggtitle(label="KGE.Q.Sobol") +   guides(scale="none")
   print(p.KGE)
   dev.copy2pdf(file=paste0(Output,"Sobol_GR6J_KGE_Q.pdf"))
    
    
   }  
 
```

<hr style="border:2px solid blue">

### 6. VARSTO
```{r, 6. SA varsto, eval=VARS.TO.eval, echo=VARS.TO.echo}
  ymat <- as.matrix(ymat)
  # Why as.character necessary?...something
  # to do with the nature of the column headers. If don't do this
  # get a matrix of characters!??
  output.names <- as.character(colnames(ymat)) 
  print(output.names)

 # Matrix of Ti outputs for between approach comparisons
  VARSTO_Results <- matrix(data=NA,nrow=length(par.names),
                          ncol=length(output.names))
  dimnames(VARSTO_Results) <- list(par.names,output.names)

 for(i in 1:length(output.names)) {
    out <- vars_to(Y=ymat[,output.names[i]],
               star.centers=star.centers,
               h=h,
               params=par.names)
     VARSTO_Results[,i] <- out$results$Ti

   barplot(height=out$results$Ti,
           names.arg=substr(out$results$parameters,1,5),
           main=output.names[i],
           cex.names=0.6)
    dev.copy2pdf(file=paste0(Output,"GR6J_VARSTO_",output.names[i],".pdf"))
 }

   print(signif(VARSTO_Results,3))
   
   #Focus on Q_{sim}
   print(cbind(VARSTO_Results[,3]*1))
   
   if(KGE.switch) {
  
   #----- Repeat w/ KGE -----------
     out <- vars_to(Y=KGE.metric,
               star.centers=star.centers,
               h=h,
               params=par.names)
     VARSTO_Results_KGE <- out$results$Ti
     barplot(height=VARSTO_Results_KGE,
           names.arg=substr(out$results$parameters,1,5),
           main="KGE.Q.VARSTO", cex.names=0.6)
    dev.copy2pdf(file=paste0(Output,"VARSTO_GR6J_KGE_Q.pdf"))
       
   }
   
   if(KGE.switch) {
     save(VARSTO_Results,VARSTO_Results_KGE,
      file=paste0(Output,"varsto_GR6J_Results.RData"))
   } else {
          save(VARSTO_Results,
      file=paste0(Output,"varsto_GR6J_Results.RData"))
   }
 
```

<hr style="border:2px solid blue">

### 7. Regression analysis
```{r, 7. Regression Analysis, eval=Reg.eval,echo=Reg.echo}
  detailed.graphics <- TRUE

  ymat         <- as.matrix(ymat)
  num.outputs  <- ncol(ymat)
  output.names <- colnames(ymat)
  cat("output names \n")
  print(output.names)
  
  Reg_Results <- matrix(data=NA,nrow=6,ncol=num.outputs)
  dimnames(Reg_Results) <- list(paste0("X",1:6),output.names)

  cat("Predictor matrix is par.sample, dim=",dim(par.sample),"\n")
  cat("names= \n");print(colnames(par.sample))
  if(detailed.graphics) {
     par(mfrow=c(2,3),oma=c(0,0,3,0))
    for(k in 1:6) {
      hist(par.sample[,k],xlab="",ylab="",main=colnames(par.sample)[k])
    }
    mytitle("Distributions of predictor vars (params)")
    par(mfrow=c(1,1))
  }
 
  X1 <- par.sample[,1]
  X2 <- par.sample[,2]
  X3 <- par.sample[,3]
  X4 <- par.sample[,4]
  X5 <- par.sample[,5]
  X6 <- par.sample[,6]
  
  predictor.df <- data.frame(X1=X1,X2=X2,X3=X3,X4=X4,X5=X5,X6=X6)
  
  r2.vals <- numeric(num.outputs)
  par(mfrow=c(2,2),oma=c(0,0,3,0))
  for(i in 1:num.outputs) {
    cat("\n \n **************************",output.names[i],"**************** \n")
    y <- ymat[,i]
    print(summary(y))
    
    if(detailed.graphics) {
         par(mfrow=c(2,3),oma=c(0,0,3,0))
         for(k in 1:6) {
         scatter.smooth(y ~ par.sample[,k],xlab=paste("X",k),ylab="",
                     main=paste("vs",colnames(par.sample)[k]))
        }
       mytitle(paste("output",output.names[i],"vs predictors"))
       par(mfrow=c(1,1))
    }

    #---- FIT SIMPLE LINEAR MULTIPLE REGRESSION ---------------#
    # Metric is the t-statistic for the covariate's coefficient
    #m <- lm(y ~ par.sample)
    m <- lm(y ~ X1 + X2 + X3 + X4 + X5 + X6)
    print(summary(m))
    temp <- summary(m)$coefficients[,"t value"]
    names(temp) <- substring(names(temp),first=11)
    #Remove the intercept
    temp <- temp[-1] 
    temp.unsort <- temp
    Reg_Results[,i] <-  abs(temp)  
    print(Reg_Results[,i])
    temp <- rev(sort(abs(temp)))
    cat("Ordering of t-stats, large to small \n")
    print(round(temp,2))
    r2.vals[i] <- summary(m)$adj.r.squared
    
    if(detailed.graphics) {
         par(mfrow=c(2,2))  #Look at "Badness" of Fit ----
         plot(m,main=paste("Reg:",output.names[i]))
        par(mfrow=c(1,1))
    }
    
   
   barplot(Reg_Results[,i],main=output.names[i],cex.names=1.1)
   title(sub=paste("R2=",round(r2.vals[i],2)))
   dev.copy2pdf(file=paste0(Output,"GR6J_Regression_",output.names[i],
                            ".pdf"))
 
  }
  par(mfrow=c(1,1))
  
 

 #----- Repeat w/ KGE Q -------
if(KGE.switch) {
    y <- KGE.metric
    m <- lm(y ~ par.sample)
    print(summary(m))
    temp <- summary(m)$coefficients[,"t value"]
    names(temp) <- substring(names(temp),first=11)
    #print(temp)
    temp.unsort <- temp[-1] 
    temp <- rev(sort(abs(temp[-1])))
    r2.vals  <- summary(m)$adj.r.squared
    
    Reg_Results_KGE <- temp.unsort
    barplot(abs(Reg_Results_KGE),main="abs t-stat: KGE.Q.MultReg",
           cex.names=0.5)
    title(sub=paste("R2=",round(r2.vals,2)))
    dev.copy2pdf(file=paste0(Output,"Regression_GR6J_KGE_Q.pdf"))
}
   
   if(KGE.switch) {
     save(Reg_Results,Reg_Results_KGE,file=paste0(Output,
       "Regression_GR6J_Results.RData"))
   } else {
     save(Reg_Results,file=paste0(Output,
       "Regression_GR6J_Results.RData"))
   }
 

```
 

<hr style="border:2px solid blue">

### 8. RegTree and Random Forest analysis and produce plots
```{r, 8. Random Forest Analysis, eval=RegTree.RF.eval,echo=RegTree.RF.echo}

  heatswitch <- FALSE # 8 Aug 2025 to speed processing

  ymat <- as.matrix(ymat)
  num.outputs  <- ncol(ymat)
  output.names <- colnames(ymat)
  # cat("output names \n")
  # print(output.names)
  ## [1] "PR 2018-07-15"   "Q9 2018-07-15"   "Qsim 2018-07-15"
  
  cat("Predictor matrix is par.sample, dim=",dim(par.sample),"\n")
  parameter.names <- colnames(par.sample)
  # cat("parameter names= \n")
  # print(parameter.names)
  ## [1] "X1" "X2" "X3" "X4" "X5" "X6"

  X1 <- par.sample[,1]
  X2 <- par.sample[,2]
  X3 <- par.sample[,3]
  X4 <- par.sample[,4]
  X5 <- par.sample[,5]
  X6 <- par.sample[,6]
  
  RandomForest_Results <- matrix(data=NA,
    nrow=length(parameter.names),
    ncol=length(output.names))
  dimnames(RandomForest_Results) <- list(parameter.names, output.names)
  RegTree_Results <- RandomForest_Results
  RegTree_Rsq <- rep(NA,num.outputs)
  names(RegTree_Rsq) <- output.names
  RF_Rsq      <- RegTree_Rsq

 # pull out the "input variables)
 var.names <- parameter.names
 num.var   <- length(var.names)
 var.df    <- par.sample[,1]
 for(j in 2:num.var) {
   var.df <- cbind(var.df,par.sample[,j])
 }
 colnames(var.df) <- var.names
 head(var.df,n=3)
 
 # *************** Regression Tree **************************
 cat("\n ***** Fitting Regression Tree  *************** \n")
  
 par(mfrow=c(1,1))
 for(i in 1:num.outputs) {
   cat("\n ********",output.names[i]," \n")
    y <- ymat[,i]
    rf.df <- data.frame(y=y,var.df)
    cat("length of y=",length(y),"df size=",dim(rf.df),"\n")

    cat("\n Fitting RegTree w/ variable importance shown \n")
    RegTree.out <- rpart(formula=y ~ ., data=rf.df)
    rpart.plot(RegTree.out,main=output.names[i])
    rpart.rules(RegTree.out)
    dev.copy2pdf(file=
      paste0(Output.rf,"GR6J_RegTree_Tree_",output.names[i],".pdf"))
    
    # Look at R^2
    tmp <- printcp(RegTree.out)
    rsq.val <- 1-tmp[,c(3,4)]  
    print(rsq.val[nrow(rsq.val),])
    RegTree_Rsq[i] <- rsq.val[nrow(rsq.val),1]
    cat("Reg Tree R^2",output.names[i],RegTree_Rsq[i],"\n")
    
    print(RegTree.out$variable.importance)
    RegTree_Results[,i] <- RegTree.out$variable.importance[var.names]
  
    
    barplot(height=RegTree_Results[,i],
            main=output.names[i],cex.names=1.1)
    dev.copy2pdf(file=paste0(Output.rf,"GR6J_RegTree_",output.names[i],
                             ".pdf"))
    
     # Adding heat map; only for Qsim
     if(i==3 & heatswitch) {
       best.predictors <- names(RegTree.out$variable.importance[1:3])
       print(best.predictors)
       short.df <- rf.df[,c("y",best.predictors)]
       print(head(short.df))
       basic.tree <- rpart(formula=y ~ ., data=short.df)
       party.tree <- as.party(basic.tree)
       heat.tree  <- heat_tree(x=party.tree,task="regression")
       print(heat.tree)
       dev.copy2pdf(file=paste0(Output.rf,
                  "GR6J_RegTree_Tree_heatmap_short_",
                  output.names[i],".pdf"))
     }
     
   }
  
  # *************** Random Forest **************************
  cat("\n ***** Fitting Random Forest *************** \n")
  
  for(i in 1:num.outputs) {
   cat("\n ********",output.names[i]," \n")
    y <- ymat[,i]
    rf.df <- data.frame(y=y,var.df)
    cat("length of y=",length(y),"df size=",dim(rf.df),"\n")
        cat("\n ********",output.names[i],"Random Forest w/ all Data \n")
    rf.out <- randomForest(formula = y ~ ., data=rf.df,importance=TRUE)
    print(rf.out)
    
    summary(rf.out)  # This is "lengthy" w/ 500 R^2 for all the trees
    temp <- summary(rf.out)
    cat("names in the rf summary \n")
    print(names(temp))
    
    # print(rf.out$rsq)  # This is "lengthy" w/ 500 R^2 for all the trees
    RF_Rsq[i] <- mean(rf.out$rsq)
    cat("RF avg R2 for", output.names[i],RF_Rsq[i],"\n")
    
    temp <- importance(rf.out)
    RandomForest_Results[,i] <- temp[,2]
    order.imp <- order(temp[,2])
    print(cbind(temp[rev(order.imp), 2]))
    randomForest::varImpPlot(x=rf.out,sort=FALSE,
                main=paste("RandomForest",output.names[i]))
    dev.copy2pdf(file=paste0(Output.rf,"GR6J_RandomForest_",output.names[i],".pdf"))
    # Training and test sets
    cat("\n", output.names[i],"RF: Training Set \n")
    y       <- ymat[,i]
    N       <- length(y)
    train.n <- floor(N*0.9)
    positions <- sample(1:N,size=train.n)
    rf.train.out <- randomForest(formula = y ~ ., data=rf.df[positions,],
                           importance=TRUE)
    print(rf.train.out)
    temp <- importance(rf.train.out)
    order.imp <- order(temp[,1])
    print(cbind(temp[rev(order.imp), 1]))

    oos.prediction <- predict(object=rf.train.out,
               newdata=rf.df[-positions,],type="response")
    x <- y[-positions]
    y <- oos.prediction
    r.gof <- cor(x,y)
    cat("length of predictions=",length(y),"\n")
    plot(x=x,y=y,
       xlab="Observed",ylab="Predicted",
       main=paste(output.names[i],"Out-of-sample Prediction, r=",
                  round(r.gof,2)))
     abline(0,1,col="blue")
     combo.RegTree.rf <- cbind(RegTree.out$variable.importance[var.names],
                            temp[,2])
    dimnames(combo.RegTree.rf) <- list(var.names,c("RegTree","RF"))
    print(round(combo.RegTree.rf,3))
    }
  dev.off()

  # Print out RegTree R^2
  cat("RegTree R^2 \n")
  print(RegTree_Rsq)
  
  # Print out Random Forest R^2
  cat("RF R^2 \n")
  print(RF_Rsq)
  
  # save results 
  save(RandomForest_Results, RegTree_Results, 
      output.names,num.outputs, # overrides version stored elsewhere
      file=paste0(Output.rf,"RandomForest_GR6J_Results.RData"))
 

```

<hr style="border:2px solid blue">

### 9. Gaussian process regression
```{r, 9. GP regression, eval=GPR.eval, echo=GPR.echo}

 # Reducing size for GPR 
 GPR.n.size       <- 500
 
 ymat             <- as.matrix(ymat)
 num.outputs      <- ncol(ymat)
 output.names     <- colnames(ymat)
 parameter.names  <- colnames(par.sample)
 print(parameter.names)
 num.params <- length(parameter.names)
 cat("In GPR, num comb=",nrow(ymat),"num outputs=",num.outputs,"\n")
  ## In GPR, num comb= 3000 num outputs= 4
 cat(" dim of parameter matrix=",dim(par.sample),"\n") 
 
 GPR_Results_invrange <- matrix(data=NA,
    nrow=length(parameter.names),
    ncol=length(output.names))
 dimnames(GPR_Results_invrange) <- list(parameter.names,output.names)
 GPR_Results_slope              <- GPR_Results_invrange

  model.list <- list()
  r2.vals <- numeric(length(num.outputs))
  par(mfrow=c(1,1),oma=c(0,0,3,0))
  for(i in 1:num.outputs) {
    cat("\n ***************Fitting GPR to",output.names[i],
        " ****** \n")
    shortened <- sort(sample(1:nrow(ymat),size=GPR.n.size))
    y <- cbind(ymat[,i])[shortened,]
    input <- par.sample[shortened,]
    # Want to standardize inputs for getting the comparable slope params
    input <- apply(input,2,scale) #has no effect on normalized inv range
    X     <- cbind(1,input)
    
     if(GPR.mean) {
      GPR <- rgasp(design=input,response=y,trend=X, nugget.est=F,
                 kernel_type="pow_exp",prior_choice='ref_approx',
                 lower_bound=FALSE)
    } else {
       GPR <- rgasp(design=input,response=y,nugget.est=F,
                 kernel_type="pow_exp",prior_choice='ref_approx',
                 lower_bound=FALSE)
    }
    
     
    cat("\n ******",output.names[i]," Summary Output from fitting \n")
    summary(GPR)
    
    if(GPR.mean) {
      slope.ests <- slot(GPR,"theta_hat")
      names(slope.ests) <- c("b0",parameter.names)
      cat("slope estimates \n")
      print(round(slope.ests,3))
      GPR_Results_slope[,i] <- slope.ests[-1]  # Remove intercept
    }
  
    cat("\n **** Results from running findInertInputs \n")
    inert.inputs <- findInertInputs(GPR)
    cat("inert inputs \n")
    names(inert.inputs) <- parameter.names
    print(round(inert.inputs,3))
    
    GPR_Results_invrange[,i] <- inert.inputs
    
   }
  par(mfrow=c(1,1))
       
save(GPR_Results_invrange,GPR_Results_slope,
     file=paste0(Output.GPR,"GPR_GR6J_Results.RData"))


```


### 9B. GPR plots- using results from above
```{r, 9B. GPR plots,  eval=GPR.eval, echo=GPR.echo}
load(file=paste0(Output.GPR,"GPR_GR6J_Results.RData"))

parameter.names  <- colnames(par.sample)

par(mfrow=c(1,1))

for(i in 1:num.outputs) {
   barplot(GPR_Results_invrange[,i],names.arg=parameter.names,
      main=paste("GPR inv range:",output.names[i]),cex.names=1.0)
   dev.copy2pdf(file=paste0(Output.GPR,"GR6J_GPR_InvRange_",
                            output.names[i],".pdf"))
}
 
  if(GPR.mean) {
   for(i in 1:num.outputs) {
    barplot(abs(GPR_Results_slope[,i]),names.arg=parameter.names,
       main=paste("GPR abs slope:",output.names[i]),cex.names=1.0)
     dev.copy2pdf(file=paste0(Output.GPR,"GR6J_GPR_Slope_",
                            output.names[i],".pdf"))
   }
  }

 # par(mfrow=c(1,2),oma=c(0,0,3,0))
 #  for(i in 1:num.outputs) {
 #   barplot(GPR_Results_invrange[,i],names.arg=parameter.names,
 #      main=paste("Inv range:",output.names[i]),cex.names=0.9)
 #   barplot(abs(GPR_Results_slope[,i]),names.arg=parameter.names,
 #      main=paste("Abs slope:",output.names[i]),cex.names=0.9)
 #   dev.copy2pdf(file=paste0(Output.GPR,"GR6J_GPR_",
 #                            substr(output.names[i],1,3),".pdf"))
 #  }
 
 #mytitle("GPR: Inverse Range & Slope")
 par(mfrow=c(1,1))
  
 
```


<hr style="border:2px solid blue">

### Elapsed Time 
```{r, Elapsed Time, eval=TRUE}
t2 <- proc.time()[3]
cat("GR6J",choice,"Time to evaluate=",round((t2-t1)/60,1),
    "minutes for",num.comb,"combos \n")
## GR6J Morris Time to evaluate= 0.1 minutes for 1001 combos
## GR6J Sobol Time to evaluate= 0.2 minutes for 10000 combos
## GR6J VARS.TO Time to evaluate= 0.1 minutes for 1045 combos
## GR6J Reg.analysis Time to evaluate= 0.2 minutes for 1000 combos
## GR6J RegTree.RF.analysis Time to evaluate= 0.6 minutes for 1000 combos
## GR6J GPR.analysis Time to evaluate= 16.9 minutes for 1000 combos #actually 500

```

 
